/*
 * Copyright 2020 Accenture Global Solutions Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = 'proto3';
package trac.metadata;

option java_package = "com.accenture.trac.common.metadata";
option java_multiple_files = true;
option java_outer_classname = "ObjectProtoWrapper";  // Do not create a Java class called "Object"!

import "google/protobuf/any.proto";
import "trac/metadata/type.proto";
import "trac/metadata/data.proto";
import "trac/metadata/model.proto";
import "trac/metadata/flow.proto";
import "trac/metadata/job.proto";
import "trac/metadata/file.proto";
import "trac/metadata/custom.proto";


/**
 * Enumeration of TRAC's core object types.
 *
 * @see ObjectDefinition
 */
enum ObjectType {
    OBJECT_TYPE_NOT_SET = 0;
    DATA = 1;
    MODEL = 2;
    FLOW = 3;
    JOB = 4;
    FILE = 5;
    CUSTOM = 6;
}


/**
 * Standard header for TRAC object definitions.
 *
 * @see ObjectDefinition
 */
message ObjectHeader {

    ObjectType objectType = 1;
    UUID objectId = 2;
    int32 objectVersion = 3;
}



/**
 * Hold data used purely for displaying an object in a client application.
 *
 * Any data that is purely related to displaying an object, such as layout
 * and styling, can be stored in the object's display properties. TRAC puts no
 * restriction on how display properties are used, applications are free to use
 * nested structures of map and array values to describe more complex layouts.
 *
 * The TRAC engine itself does not use display properties, they will not be
 * available to models at run time, to clients using the data API or to third-
 * party systems accessing data through other methods of integration. For this
 * reason, information such as labels and data field formats should be included
 * in the core object model.
 *
 * Different applications may use different display properties even if they
 * connected to the same instance of TRAC. Each application is free to create
 * its own set of display properties, or to interpret properties created by
 * another application. TRAC does not prevent applications writing display
 * properties under the name of another application, although this is not
 * recommended!
 */
message DisplayProperties {

    /**
     * Name of the application that generated these display properties.
     *
     * This field is provided so multiple applications can record their own
     * display properties if they are accessing the same TRAC instance. For
     * example, a generic workbench/admin tool may be used alongside a business UI
     * built for a specific use case. Applications are free to use display info
     * that was created by another tool.
     *
     * TRAC does not prevent applications writing display properties under the
     * name of another application, although this is not recommended.
     */
    string applicationName = 1;

    /**
     * Version field to let applications change how they store display properties.
     *
     * Applications may change the way the store display properties between
     * versions, in which case this field can be used to check compatibility.
     * The structure used to store display properties can be thought of as a
     * schema, with this field providing a schema version. Applications are free
     * to use (or not use) this "display schema versioning" as they find useful.
     */
    int32 displayVersion = 2;

    /**
     * The display properties.
     *
     * TRAC puts no restriction on how display properties are used. Applications
     * are free to use nested structures of map and array values to describe more
     * complex layouts.
     */
    map <string, Value> property = 3;
}


// TODO: Structure and docs for custom props
message CustomProperties {

}

/**
 * Object definitions are the core structural element of TRAC's metadata model.
 *
 * Definitions describe every object that is stored in the TRAC platform and there
 * is a one-to-one relation between definitions and objects. I.e. every dataset
 * has its own data definition, every model has its own model definition and so
 * on. Definitions also describe actions that take place on the platform by way of
 * job definitions, so a "job" is just another type of object. Each type of object
 * has its own definition and definitions can be added or extended as the platform
 * evolves.
 *
 * The object definition container class allows different types of objects to be
 * stored, indexed and accessed in the same way. Every object has a standard
 * object header which contains enough information to identify the object.
 *
 * TRAC object definitions can be versioned. In order to use versioning the
 * semantics of versioning must be defined and those vary depending on the object
 * type. Currently these semantics are defined for DATA objects, see
 * DataDefinition for details. Versioning is also allowed for CUSTOM objects, in
 * this case it is the responsibility of the application to define versioning
 * semantics. Versioning is not currently permitted for other object types.
 *
 * Object definitions are intended for storing structural data necessary to access
 * data and run jobs on the TRAC platform. Informational data to catalogue and
 * describe objects is stored in tags. Tags are a lot more flexible than object
 * definitions, so applications built on the TRAC platform may choose to store
 * structural information in tags where their required structure is not supported
 * by TRAC's core object definitions.
 *
 * TODO: Document display props, custom props and extensions
 *
 * @see Tag
 * @see ObjectHeader
 */
message ObjectDefinition {

    ObjectHeader header = 1;

    oneof definition {
        DataDefinition data = 2;
        ModelDefinition model = 3;
        FlowDefinition flow = 4;
        JobDefinition job = 5;
        FileDefinition file = 6;
        CustomDefinition custom = 7;
    }

    // Extensions

    repeated DisplayProperties display = 1000;
    repeated CustomProperties properties = 1001;  // TODO: Find a good name that isn't "custom" (or rename custom def)
    repeated google.protobuf.Any extension = 1002;
}
